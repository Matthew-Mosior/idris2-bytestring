module Data.Buffer.Indexed.Old

-- import Algebra.Solver.Semiring
-- import Network.FFI
-- import Network.Socket.Raw
-- import System.File
-- import public Data.Buffer
-- import public Data.Buffer.Index
-- import public Data.Nat.BSExtra
--
-- %default total
--
--
-- --------------------------------------------------------------------------------
-- --          IBuffer
-- --------------------------------------------------------------------------------
--
-- ||| Reads the value of a `ByteString` at the given position
-- export %inline
-- byteAtO : (o : Nat) -> IBuffer n -> (0 off : Offset (S c) o n) => Bits8
-- byteAtO o buf = byteAt o buf {lt = offsetLTE off}
--
-- ||| Reads the value of a `ByteString` conting from the end of the buffer
-- export %inline
-- byteFromEnd :
--      {end : _}
--   -> (x : Nat)
--   -> {auto 0 lt : LT x end}
--   -> IBuffer n
--   -> {auto 0 lte : LTE end n}
--   -> Bits8
-- byteFromEnd x (Buf buf) =
--   prim__getByte buf (natToInteger end - natToInteger x - 1)
--
-- %inline
-- writeByte :  (x : Nat) -> (v : Bits8) -> Buffer -> PrimIO ()
-- writeByte x v buf = prim__setByte buf (cast x) v
--
--
-- --------------------------------------------------------------------------------
-- --          Reading and Writing from and to Files
-- --------------------------------------------------------------------------------
--
-- ||| Wrappes a mutable buffer in an `IBuffer`.
-- |||
-- ||| Client code is responsible to make sure the original buffer is no longer
-- ||| used.
-- export
-- unsafeMakeBuffer : Buffer -> IBuffer k
-- unsafeMakeBuffer = Buf
--
-- ||| Wrappes a mutable of known size in a `ByteString`.
-- |||
-- ||| Client code is responsible to make sure the original buffer is no longer
-- ||| used.
-- export
-- unsafeByteString : (k : Nat) -> Buffer -> ByteString
-- unsafeByteString k b = BS k $ BV (unsafeMakeBuffer {k} b) 0 %search
--
-- export
-- readBuffer :  HasIO io => Nat -> File -> io (Either FileError (k ** IBuffer k))
-- readBuffer max f =
--   let buf  := prim__newBuf (cast max)
--    in do
--     Right read <- readBufferData f buf 0 (cast max)
--       | Left err => pure (Left err)
--     if read >= 0
--        then pure (Right (cast read ** Buf buf))
--        else pure (Left FileReadError)
--
-- export
-- writeBuffer :
--      {auto _ : HasIO io}
--   -> File
--   -> (offset,size : Nat)
--   -> IBuffer n
--   -> io (Either (FileError,Int) ())
-- writeBuffer h o s (Buf buf) = writeBufferData h buf (cast o) (cast s)
--
-- export
-- readByteString :
--      {auto _ : HasIO io}
--   -> Nat
--   -> File
--   -> io (Either FileError ByteString)
-- readByteString max f = do
--   Right (k ** buf) <- readBuffer max f | Left err => pure (Left err)
--   pure $ Right (BS k $ BV buf 0 refl)
--
-- export %inline
-- writeByteVect :
--      {n : _}
--   -> {auto _ : HasIO io}
--   -> File
--   -> ByteVect n
--   -> io (Either (FileError,Int) ())
-- writeByteVect h (BV buf o _) = writeBuffer h o n buf
--
-- export %inline
-- writeByteString :
--      {auto _ : HasIO io}
--   -> File
--   -> ByteString
--   -> io (Either (FileError,Int) ())
-- writeByteString h (BS n bs) = writeByteVect h bs
--
-- export
-- recvBuffer :
--      {auto _ : HasIO io}
--   -> Nat
--   -> Socket
--   -> io (Either SocketError (k ** IBuffer k))
-- recvBuffer max sock = do
--   Just buffer <- newBuffer (cast max) | Nothing => pure $ Left (-1)
--   ret <- primIO $ prim__idrnet_recv_bytes sock.descriptor buffer (cast max) 0
--   case ret >= 0 of
--     False => pure $ Left ret
--     True  => pure $ Right (cast ret ** Buf buffer)
--
-- export
-- recvByteString :
--      {auto _ : HasIO io}
--   -> Nat
--   -> Socket
--   -> io (Either SocketError ByteString)
-- recvByteString max sock = do
--   Right (k ** buf) <- recvBuffer max sock | Left err => pure (Left err)
--   pure $ Right (BS k $ BV buf 0 refl)
